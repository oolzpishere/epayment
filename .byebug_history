quit
@payment_products.first["single_price"].humanize
@payment_products.first["single_price"].to_s
@payment_products.first["single_price"].to_h
@payment_products.first["single_price"]
@payment_products[]
money.fee
money  = ::Epayment::Money.new(3)
::Epayment::Money.new(3)
@payment_products["single_price"]
@payment_products
c
Epayment.test_mode
c
Rails.env.development?
Rails.env
RAILS_ENV
env
RAILS.env
c
current_url.match(/#{current_host}:\d+/).to_s
current_url.match(/#{current_host}:\d+/)[0]
current_url.match(/#{current_host}:\d+/).first
current_url.match(/#{current_host}:\d+/)
current_url.match(/#{current_host}\d+/)
current_url.match(/#{current_host}.+\//)
current_url.match(/#{current_host}\d+\//)
current_url.match(/#{current_host}\d*\//)
current_url.match(/#{current_host}/)
current_url
@responds
@respons
@request
request
request.host
methods
url
port
host
c
assert_requested(stub)
stub = stub_request(:post, "www.example.com")
uri.to_s
uri
assert_requested(uri.to_s)
assert_requested(uri)
res = Net::HTTP.start(uri.host, uri.port) {|http|  http.request(req, 'hello world') }
res = Net::HTTP.start(uri.host, uri.port) do |http|
end
  http.request(req, 'hello world')
res = Net::HTTP.start(uri.host, uri.port) do |http|
req['Content-Type'] = 'image/png'
req = Net::HTTP::Post.new(uri.path)
uri = URI.parse('http://www.example.com/')
require 'restclient'
require 'rest_client'
req = Net::HTTP::Post.new("www.example.com/wechat_pay_unifiedorder")
Net::HTTP::Post
RestClient
c
current_path
current_port
current_url
current_host
curren_host
methods
port
host
@request
@response
@response.methods
@response.original_url
response.original_url
response.host
c
where
c
where
thread list
thread current
thread currnt
thread
help
c
quit
c
click_button "commit"
c
click_button "pay button"
quit
post "/set_fake_wechat_base_session"
File.write('test2', response.body)
post "/set_fake_wechat_base_session"
quit
post '/payment_gateway/update_wechat_pay'
File.write('./test.html', response.body)
File.write('.', response.body)
response.body
`ls -al`
response.body
post '/payment_gateway/update_wechat_pay'
c
`ls`
`ll`
response.body
@request.methods
request.methods
request.parsed_body
request.body
request
post '/payment_gateway/update_wechat_pay'
@response.to_json
@response.methods
@response.body_parts
@response.methods
@
@response.parsed_body
@response.success?
@response.methods
@response.error?
@response.error
@response.status
@response.statu
@response
@request.statu
@request.status
@request
 post '/payment_gateway/update_wechat_pay'
c
quit
post '/payment_gateway/update_wechat_pay'
post '/payment_gateway/update_wechat_pay',params: {}
post '/payment_gateway/update_wechat_pay',,
    params: {}
'/payment_gateway/update_wechat_pay' == '/payment_gateway/update_wechat_pay'
get "/set_after_payment_redirection_path"
c
post '/payment_gateway/update_wechat_pay'
c
quit
post payment_gateway_update_wechat_pay_path, as: :json
post payment_gateway_update_wechat_pay_path, as: json
post payment_gateway_update_wechat_pay_path
show-source post
[{name: "product_name", single_price: 2, num: 1}].map {|h| h.stringify}
[{name: "product_name", single_price: 2, num: 1}].map {|h| h.stringfy}
{a: 1, b: 2}.slice(:a)
{a: 1, b: 2}.select(:a)
{a: 1, b: 2}
uri.to_s
uri
uri.query = "id=30&limit=5"
uri.host
uri
uri = URI("http://foo.com/posts")
uri = URI("uri = URI("http://foo.com/posts")
{}[:a]
rand(36 ** 3).to_s(36)
rand(36 ** 3)
self.try = 1
self.try
self.try= (1)
self.respond_to?(:tr)
self.respond_to?(:try)
self.respond_to?(:try=)
try=(1)
end
  puts "calling try= #{x}"
def try= (x)
try=('a')
try=(1)
puts "call try"
@try
try
end
  puts "call try"
def try 
try= 1
try = 1
end
  puts "calling try="
def try= (x)
arr.length
arr
arr =  a.split(/\n/) 
puts a.split(/\n/) 
a.split(/\n/) 
a.split(/\s/) 
a.split(\s) 
a.split('\\n') 
a.split('\n') 
a
3283329"
337
3253323
334
3223323
331
3193323
318
317
316
315
314
313
312
311
310
309
308
307
306
305
304
303
302
301
300
299
298
297
296
295
294
293
292
291
290
289
288
287
286
285
284
283
